<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>StoneAge 마쥬의 미로 네비게이션</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#050712;
      --panel:#10131f;
      --accent:#6aa0ff;
      --text:#e6ecff;
      --muted:#9aa0b5;
      --border:#262b40;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      background:radial-gradient(circle at top,#1c2540 0,#050712 55%);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      padding:16px;
    }

    .page{
      max-width:980px;
      margin:0 auto;
    }

    .page-header{
      margin-bottom:10px;
    }
    .title-wrap{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    h1{
      font-size:1.15rem;
      letter-spacing:0.02em;
    }
    .subtitle{
      font-size:0.8rem;
      color:var(--muted);
    }

    /* 상단 사용자 컨트롤 카드 */
    .controls-card{
      background:var(--panel);
      border-radius:12px;
      padding:10px 12px;
      box-shadow:0 6px 18px rgba(0,0,0,.4);
      margin-bottom:10px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .controls-row{
      display:flex;
      flex-wrap:wrap;
      gap:8px 16px;
      align-items:center;
    }
    .controls-row + .controls-row{
      margin-top:6px;
    }

    .controls-label{
      font-size:0.75rem;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
    }
    .controls-select{
      font-size:.8rem;
      padding:2px 6px;
      border-radius:6px;
      border:1px solid #23263b;
      background:#0d1020;
      color:var(--text);
    }

    .btn{
      padding:6px 12px;
      border-radius:8px;
      border:none;
      font-size:.9rem;
      cursor:pointer;
      background:var(--accent);
      color:#fff;
      font-weight:600;
      white-space:nowrap;
      transition:background 0.15s ease, transform 0.08s ease;
    }
    .btn.secondary{
      background:#424867;
    }
    .btn:active{
      transform:translateY(1px);
    }

    .spacer{flex:1;}
    .coord-live{
      font-size:.8rem;
      color:#a5ffb8;
      white-space:nowrap;
    }

    /* 캡쳐 영역 */
    .stage-wrap{
      padding:8px;
      border-radius:12px;
      background:rgba(0,0,0,.35);
      box-shadow:0 10px 30px rgba(0,0,0,.6) inset;
      max-width:100%;
      overflow:auto;
      border:1px solid rgba(0,0,0,0.6);
    }
    #stage{
      position:relative;
      display:inline-block;
      border-radius:10px;
      overflow:hidden;
      border:1px solid var(--border);
      background:#000;
    }
    #screenVideo{display:block;}
    #navCanvas{
      position:absolute;
      left:0;
      top:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    .pip-overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:#000;
      color:#fff;
      font-size:1.3rem;
      font-weight:600;
      z-index:10;
      pointer-events:none;
    }

    /* 관리자 / OCR 패널 */
    .section-title{
      margin-top:12px;
      margin-bottom:6px;
      font-size:0.9rem;
      font-weight:600;
      color:#f5f7ff;
    }
    .section-note{
      font-size:0.75rem;
      color:var(--muted);
      margin-bottom:4px;
    }

    .ocr-panel{
      margin-top:10px;
      background:var(--panel);
      border-radius:12px;
      padding:8px 10px 10px;
      box-shadow:0 6px 18px rgba(0,0,0,.35);
      font-size:.8rem;
      border:1px solid rgba(255,255,255,0.03);
    }
    #coordCanvas{
      border:1px solid #444a66;
      background:#000;
    }
    .ocr-result{
      font-size:.8rem;
      color:#ffe08a;
      white-space:pre-line;
    }

    .admin-only{display:none;}
    body.admin-mode .admin-only{
      display:flex;
      flex-wrap:wrap;
      gap:8px 12px;
      align-items:flex-start;
      margin-top:8px;
    }

    .admin-field-group{
      display:flex;
      flex-wrap:wrap;
      gap:6px 10px;
      align-items:center;
      margin-bottom:4px;
    }
    .admin-field-group label{
      font-size:.75rem;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:4px;
    }
    .admin-field-group input[type="number"],
    .admin-field-group input[type="text"]{
      width:60px;
      padding:2px 4px;
      border-radius:4px;
      border:1px solid #30344a;
      background:#050716;
      color:var(--text);
      font-size:0.75rem;
    }

    .config-tools{
      display:flex;
      flex-wrap:wrap;
      gap:6px 10px;
      align-items:center;
      font-size:0.75rem;
      margin-top:4px;
    }
    .config-tools button{
      font-size:0.75rem;
      padding:4px 8px;
    }
    .config-tools input[type="file"]{
      font-size:0.7rem;
    }

    /* 사용 방법 / 안내 */
    .hint{
      margin-top:12px;
      font-size:0.8rem;
      color:#FAFAF8;
      line-height:1.5;
      background:rgba(0,0,0,0.35);
      border-radius:12px;
      padding:10px 12px 12px;
      border:1px solid rgba(255,255,255,0.03);
    }
    .hint-block + .hint-block{
      margin-top:10px;
    }
    .hint-title{
      font-weight:600;
      margin-bottom:4px;
    }
    .hint-list{
      padding-left:18px;
      margin:4px 0 0;
    }
    .hint-list li{
      margin:2px 0;
    }
    .hint-strong{
      font-weight:600;
    }
  </style>
</head>
<body>
  <div class="page">
    <header class="page-header">
      <div class="title-wrap">
        <h1>StoneAge 마쥬의 미로 네비게이션</h1>
        <p class="subtitle">
          게임 화면 우측 하단 좌표를 OCR로 읽어, 현재 위치 기준으로 미로 이동 경로를 안내하는 도우미입니다.
        </p>
      </div>
    </header>

    <!-- 사용자용 상단 컨트롤 -->
    <section class="controls-card">
      <div class="controls-row">
        <button id="startBtn" class="btn">캡쳐 시작</button>

        <label class="controls-label">
          서버
          <select id="serverSelect" class="controls-select">
            <option value="NOVA&HAPPY">NOVA &amp; HAPPY</option>
            <option value="WIND">WIND</option>
          </select>
        </label>

        <label class="controls-label">
          층
          <select id="floorSelect" class="controls-select">
            <option value="1F">1층</option>
            <option value="2F">2층</option>
            <option value="3F">3층</option>
            <option value="4F">끈돌</option>
          </select>
        </label>

        <div class="spacer"></div>

        <span id="coordLive" class="coord-live">현재 좌표: -</span>
        <button id="adminToggle" class="btn secondary">관리자 모드</button>
      </div>

      <div class="controls-row">
        <button id="ocrOnceBtn" class="btn">좌표 OCR 1회 테스트</button>
        <button id="autoOcrToggle" class="btn">자동 추적 시작</button>
        <button id="pipBtn" class="btn secondary">PIP 모드로 보기</button>
      </div>
    </section>

    <!-- 캡쳐 + 네비 라인 -->
    <section class="stage-section">
      <div class="stage-wrap">
        <div id="stage">
          <video id="screenVideo" autoplay playsinline></video>
          <canvas id="navCanvas"></canvas>
          <div id="pipOverlay" class="pip-overlay">
            PIP 모드에서 재생 중
          </div>
        </div>
      </div>
    </section>

    <!-- 관리자 전용 OCR 상세 설정 -->
    <section class="ocr-section">
      <h2 class="section-title">관리자 설정 (OCR 좌표 & 템플릿)</h2>
      <p class="section-note">
        관리자 모드에서만 세부 좌표 영역과 숫자 템플릿을 수정할 수 있습니다.
        서버별 설정은 별도의 JSON(<code>majyu_ocr_servers.json</code>)로 관리됩니다.
      </p>

      <div class="ocr-panel">
        <div class="admin-only">
          <div>
            <div class="admin-field-group">
              <label>동 X <input id="eastX"  type="number" value="880"></label>
              <label>Y   <input id="eastY"  type="number" value="780"></label>
              <label>W   <input id="eastW"  type="number" value="20"></label>
              <label>H   <input id="eastH"  type="number" value="17"></label>
            </div>

            <div class="admin-field-group">
              <label>남 X <input id="southX" type="number" value="930"></label>
              <label>Y   <input id="southY" type="number" value="780"></label>
              <label>W   <input id="southW" type="number" value="20"></label>
              <label>H   <input id="southH" type="number" value="17"></label>
            </div>

            <canvas id="coordCanvas" width="160" height="24"></canvas>
          </div>

          <div style="flex:1;min-width:220px;display:flex;flex-direction:column;gap:6px;">
            <div class="ocr-result" id="ocrResult">OCR 결과가 여기 표시됩니다.</div>

            <div class="admin-field-group" style="margin-top:4px;">
              <span style="font-size:0.75rem;">학습용 동 좌표:</span>
              <input id="learnEastValue" type="text" maxlength="3" style="width:56px;">
              <button id="learnEastBtn" class="btn" style="font-size:0.75rem;padding:4px 8px;">동 템플릿 학습</button>
              <button id="clearTemplatesBtn" class="btn secondary" style="font-size:0.75rem;padding:4px 8px;">템플릿 초기화</button>
            </div>

            <div class="ocr-result" id="templateStatus">템플릿 상태: 없음</div>

            <div class="config-tools">
              <button id="exportConfigBtn" class="btn secondary">서버 설정 JSON 내보내기</button>
              <label>
                JSON 불러오기
                <input id="importConfigInput" type="file" accept="application/json">
              </label>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 사용 방법 / 참고 사항 -->
    <section class="guide-section">
      <div class="hint">
        <div class="hint-block">
          <div class="hint-title">▶ 사용 순서</div>
          <ol class="hint-list">
            <li>StoneAge를 <span class="hint-strong">"1024×768"</span> 해상도의 창모드로 실행합니다.</li>
            <li>게임 내 폰트를 <span class="hint-strong">"굴림체"</span>로 변경합니다.</li>
            <li><span class="hint-strong">캡쳐 시작</span> 버튼을 누르고, 게임 창을 선택합니다.</li>
            <li>게임 화면 우측 하단의 좌표(동/남)가 잘 보이도록 창 위치를 조정합니다.</li>
            <li><span class="hint-strong">자동 추적 시작</span> 버튼을 누르면 좌표와 네비 라인이 자동으로 갱신됩니다.</li>
            <li>
              <span class="hint-strong">1~3층은 자동으로 층수 전환</span>이 되며,<br>
              3층까지 마무리 후 캡쳐를 종료했다가 끈 자르는 돌을 구비한 뒤 다시 1층에 진입하여,<br>
              층 선택을 수동으로 <span class="hint-strong">"끈돌"</span>로 바꾼 뒤 다시 캡쳐를 시작합니다.
            </li>
          </ol>
        </div>

        <div class="hint-block">
          <div class="hint-title">★ 참고 사항</div>
          <ul class="hint-list">
            <li>끈 보따리 좌표는 각각 <span class="hint-strong">(281,48) / (163,12) / (145,54)</span> 입니다.</li>
            <li>
              캡쳐 종료 후 윈도우 자체 렉이 발생할 경우<br>
              <span class="hint-strong">Ctrl + Alt + Del → 작업 관리자 → Windows 탐색기(explorer.exe) 다시 시작</span>을 시도해 주세요.
            </li>
          </ul>
        </div>

        <div class="hint-block">
          <div class="hint-title">☆ 문의 및 기타</div>
          <ul class="hint-list">
            <li>유틸 관련 문의는 <span class="hint-strong">과장(kokodas#0339)</span>에게 디스코드로 연락 주세요.</li>
            <li>소스를 따옴/수정하실 경우, <span class="hint-strong">사전 연락 또는 출처 표기</span>를 부탁드립니다.</li>
            <li>테스트 완료 서버 : <span class="hint-strong">NOVA, HAPPY</span></li>
          </ul>
        </div>
      </div>
    </section>
  </div>

<script>
  // ==========================
  // 0. 기본 설정 / 전역 상태
  // ==========================
  const CONFIG_URL = "data/majyu_ocr_servers.json"; // GitHub 내 JSON 경로

  let serverConfig = { version: 1, servers: {} };
  let currentServerId = "NOVA&HAPPY";

  // 네비 경로 정의(실제 데이터는 따로 관리)
  let FLOOR_PATHS = {};
  /*
  // 실제 프로젝트에서 사용할 FLOOR_PATHS 예시 (여기에 원본 데이터 붙여 넣기)
  FLOOR_PATHS = {
    "1F": { label: "미로 1층", raw: [ ... ] },
    "2F": { label: "미로 2층", raw: [ ... ] },
    "3F": { label: "미로 3층", raw: [ ... ] },
    "4F": { label: "끈돌",    raw: [ ... ] }
  };
  */

  // 빌트인 템플릿이 필요하면 여기에 따로 붙여 넣을 수 있음
  const BUILTIN_TEMPLATES = {};
  /*
  const BUILTIN_TEMPLATES = {
    "0": [ ... ],
    "1": [ ... ],
    ...
    "9": [ ... ]
  };
  */

  // ========== 1. DOM 참조 ==========
  const startBtn      = document.getElementById('startBtn');
  const video         = document.getElementById('screenVideo');
  const navCanvas     = document.getElementById('navCanvas');
  const navCtx        = navCanvas.getContext('2d');
  const pipOverlay    = document.getElementById('pipOverlay');

  const floorSelect   = document.getElementById('floorSelect');
  const ocrOnceBtn    = document.getElementById('ocrOnceBtn');
  const autoBtn       = document.getElementById('autoOcrToggle');
  const coordLive     = document.getElementById('coordLive');
  const pipBtn        = document.getElementById('pipBtn');
  const serverSelect  = document.getElementById('serverSelect');

  const coordCanvas   = document.getElementById('coordCanvas');
  const coordCtx      = coordCanvas.getContext('2d');
  const ocrResultDiv  = document.getElementById('ocrResult');
  const templateStatus= document.getElementById('templateStatus');

  const learnEastInput    = document.getElementById('learnEastValue');
  const learnEastBtn      = document.getElementById('learnEastBtn');
  const clearTemplatesBtn = document.getElementById('clearTemplatesBtn');
  const exportConfigBtn   = document.getElementById('exportConfigBtn');
  const importConfigInput = document.getElementById('importConfigInput');

  const eastXInput  = document.getElementById('eastX');
  const eastYInput  = document.getElementById('eastY');
  const eastWInput  = document.getElementById('eastW');
  const eastHInput  = document.getElementById('eastH');
  const southXInput = document.getElementById('southX');
  const southYInput = document.getElementById('southY');
  const southWInput = document.getElementById('southW');
  const southHInput = document.getElementById('southH');

  // PiP 관련
  let pipVideo   = null;
  const pipCanvas= document.createElement('canvas');
  const pipCtx   = pipCanvas.getContext('2d');
  let pipActive  = false;
  let pipAnimating = false;

  // OCR / 캡쳐 상태
  const OCR_INTERVAL = 200;
  let currentStream  = null;

  // ============ 2. 캡쳐 제어 ============
  function setMainOverlayForPip(active){
    if (active){
      if (video)     video.style.opacity = '0';
      if (navCanvas) navCanvas.style.opacity = '0';
      if (pipOverlay) pipOverlay.style.display = 'flex';
    }else{
      if (video)     video.style.opacity = '1';
      if (navCanvas) navCanvas.style.opacity = '1';
      if (pipOverlay) pipOverlay.style.display = 'none';
      updateNavigation();
    }
  }

  function cleanupCapture() {
    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
    video.srcObject = null;
    stopAutoOcr();
    clearNavPath();

    pipAnimating = false;
    if (document.pictureInPictureElement === pipVideo) {
      document.exitPictureInPicture().catch(()=>{});
    }
    pipActive = false;
    if (pipBtn) pipBtn.textContent = 'PIP 모드로 보기';

    setMainOverlayForPip(false);
  }

  startBtn.addEventListener('click', async () => {
    try {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
        alert('이 브라우저에서는 화면 캡쳐(getDisplayMedia)를 지원하지 않습니다.');
        return;
      }

      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: { frameRate: 30 },
        audio: false
      });

      currentStream = stream;
      video.srcObject = stream;

      const [videoTrack] = stream.getVideoTracks();
      if (videoTrack) {
        videoTrack.addEventListener('ended', () => {
          console.log('캡쳐가 시스템/브라우저에서 종료됨');
          cleanupCapture();
          currentEast = currentSouth = null;
        });
      }

      video.onloadedmetadata = () => {
        video.play().catch(()=>{});
        if (navCanvas) {
          navCanvas.width  = video.videoWidth;
          navCanvas.height = video.videoHeight;
        }
      };
    } catch (err) {
      console.error(err);
      alert('화면 캡쳐 권한을 얻지 못했습니다.\n다시 시도해 주세요.');
    }
  });

  window.addEventListener('beforeunload', cleanupCapture);

  // ===============================
  // 3. 네비 경로 / 층 자동 전환 로직
  // ===============================
  function expandPath(nodes) {
    const out = [];
    for (let i = 0; i < nodes.length - 1; i++) {
      const a = nodes[i];
      const b = nodes[i + 1];

      let e = a.e;
      let s = a.s;
      const stepE = Math.sign(b.e - a.e);
      const stepS = Math.sign(b.s - a.s);

      out.push({ e, s });
      while (e !== b.e || s !== b.s) {
        if (e !== b.e) e += stepE;
        if (s !== b.s) s += stepS;
        out.push({ e, s });
      }
    }
    const last = nodes[nodes.length - 1];
    out.push({ e: last.e, s: last.s });
    return out;
  }

  const FLOOR_PATH_POINTS = {};
  for (const id in FLOOR_PATHS) {
    FLOOR_PATH_POINTS[id] = expandPath(FLOOR_PATHS[id].raw);
  }

  let currentFloorId = "1F";
  let pathPoints     = FLOOR_PATH_POINTS[currentFloorId] || [];

  function clearNavPath() {
    if (!navCanvas || !navCtx) return;
    navCtx.clearRect(0, 0, navCanvas.width, navCanvas.height);
  }

  function applyFloor(newFloorId, resetHistory = true) {
    const pts = FLOOR_PATH_POINTS[newFloorId];
    if (!pts || !pts.length) {
      console.warn("정의되지 않은 층 또는 경로 없음:", newFloorId);
      return;
    }
    currentFloorId = newFloorId;
    pathPoints = pts;

    if (floorSelect && floorSelect.value !== newFloorId) {
      floorSelect.value = newFloorId;
    }

    if (resetHistory) {
      eastHistory  = [];
      southHistory = [];
    }

    clearNavPath();
    updateNavigation();
  }

  floorSelect.addEventListener('change', () => {
    applyFloor(floorSelect.value, true);
  });

  const PATH_SNAP_MAX_DIST  = 2;
  const LOOK_AHEAD_SEGMENTS = 25;
  const AUTO_FLOORS         = ["1F", "2F", "3F"];
  const AUTO_FLOOR_MAX_DIST = 3;
  const FLOOR_CHANGE_MARGIN = 1;
  const FLOOR_ORDER = {
    "1F": 1,
    "2F": 2,
    "3F": 3
  };

  const CHAR_OFFSET_X = 0;
  const CHAR_OFFSET_Y = 14;
  const TILE_STEP_X   = 32;
  const TILE_STEP_Y   = 24;

  function findClosestIndexOnPath(e, s, pts) {
    if (!pts || !pts.length) return { index:-1, dist:Infinity };
    let bestIndex = -1, bestDist = Infinity;
    for (let i = 0; i < pts.length; i++) {
      const p = pts[i];
      const dist = Math.abs(p.e - e) + Math.abs(p.s - s);
      if (dist < bestDist) {
        bestDist  = dist;
        bestIndex = i;
      }
    }
    return { index:bestIndex, dist:bestDist };
  }

  function findClosestPathIndex(e, s) {
    const res = findClosestIndexOnPath(e, s, pathPoints);
    if (res.dist > PATH_SNAP_MAX_DIST) return -1;
    return res.index;
  }

  function autoDetectFloorByCoord(e, s) {
    if (currentFloorId === "4F") return false;
    if (e == null || s == null) return false;

    const curPts = FLOOR_PATH_POINTS[currentFloorId];
    const curRes = findClosestIndexOnPath(e, s, curPts);
    const curDist = curRes.dist;

    let bestFloor = currentFloorId;
    let bestDist  = curDist;

    for (const floorId of AUTO_FLOORS) {
      if (floorId === currentFloorId) continue;

      const pts = FLOOR_PATH_POINTS[floorId];
      if (!pts || !pts.length) continue;

      const res = findClosestIndexOnPath(e, s, pts);

      if (res.dist + FLOOR_CHANGE_MARGIN < bestDist) {
        bestDist  = res.dist;
        bestFloor = floorId;
      }
    }

    if (bestFloor === currentFloorId) return false;
    if (bestDist > AUTO_FLOOR_MAX_DIST) return false;

    if (FLOOR_ORDER[bestFloor] < FLOOR_ORDER[currentFloorId]) {
      return false;
    }
    if (Math.abs(FLOOR_ORDER[bestFloor] - FLOOR_ORDER[currentFloorId]) > 1) {
      return false;
    }

    console.log(
      `auto floor change: ${currentFloorId} → ${bestFloor} (curDist=${curDist}, bestDist=${bestDist})`
    );

    applyFloor(bestFloor, false);
    return true;
  }

  function esToScreenOffset(dE, dS) {
    const dx = TILE_STEP_X * (dE + dS);
    const dy = TILE_STEP_Y * (dS - dE);
    return { dx, dy };
  }

  function drawNavPathFrom(idxStart) {
    if (!navCanvas || !navCtx) return;
    if (!pathPoints || !pathPoints.length) return;
    clearNavPath();
    if (currentEast == null || currentSouth == null) return;
    if (idxStart < 0 || idxStart >= pathPoints.length) return;

    const centerX = navCanvas.width  / 2 + CHAR_OFFSET_X;
    const centerY = navCanvas.height / 2 + CHAR_OFFSET_Y;

    navCtx.lineWidth   = 3;
    navCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
    navCtx.lineJoin    = 'round';
    navCtx.lineCap     = 'round';

    navCtx.beginPath();
    navCtx.moveTo(centerX, centerY);

    const lastIndex = Math.min(pathPoints.length - 1,
                               idxStart + LOOK_AHEAD_SEGMENTS);

    for (let i = idxStart; i <= lastIndex; i++) {
      const p  = pathPoints[i];
      const dE = p.e - currentEast;
      const dS = p.s - currentSouth;
      const { dx, dy } = esToScreenOffset(dE, dS);
      navCtx.lineTo(centerX + dx, centerY + dy);
    }
    navCtx.stroke();
  }

  function updateNavigation() {
    if (currentEast == null || currentSouth == null || !pathPoints || !pathPoints.length) {
      clearNavPath();
      return;
    }
    const idx = findClosestPathIndex(currentEast, currentSouth);
    if (idx < 0) {
      clearNavPath();
      return;
    }
    drawNavPathFrom(idx);
  }

  // =======================
  // 4. OCR / 템플릿 관련 로직
  // =======================
  let currentEast  = null;
  let currentSouth = null;
  let ocrLoopTimer = null;
  let ocrBusy      = false;

  const MAX_STEP     = 15;
  const HISTORY_SIZE = 5;
  let eastHistory  = [];
  let southHistory = [];

  function smoothCoord(prev, now) {
    if (now == null || Number.isNaN(now)) return prev;
    if (prev == null) return now;
    if (Math.abs(now - prev) > MAX_STEP) {
      console.log(`jump filtered: prev=${prev}, now=${now}`);
      return prev;
    }
    return now;
  }
  function pushHistory(list, value) {
    if (value == null || Number.isNaN(value)) return;
    list.push(value);
    if (list.length > HISTORY_SIZE) list.shift();
  }
  function majorityValue(list) {
    const counts = {};
    for (const v of list) {
      if (v == null) continue;
      counts[v] = (counts[v] || 0) + 1;
    }
    let bestVal = null, bestCnt = 0;
    for (const [k, c] of Object.entries(counts)) {
      if (c > bestCnt) {
        bestCnt = c;
        bestVal = parseInt(k, 10);
      }
    }
    return { value:bestVal, count:bestCnt };
  }

  const DIGIT_W = 8;
  const DIGIT_H = 14;

  const digitTemplates = { 0:null,1:null,2:null,3:null,4:null,5:null,6:null,7:null,8:null,9:null };

  function updateTemplateStatus() {
    if (!templateStatus) return;
    const have = [];
    for (let d = 0; d <= 9; d++) {
      if (digitTemplates[d]) have.push(d);
    }
    templateStatus.textContent =
      '템플릿 상태: ' + (have.length ? have.join(', ') + ' 학습됨' : '없음');
  }

  const ocrCanvas = document.createElement('canvas');
  const ocrCtx    = ocrCanvas.getContext('2d');

  function binarizeRegion(rect, preview=false, threshold=150) {
    const { x, y, w, h } = rect;
    ocrCanvas.width  = w;
    ocrCanvas.height = h;

    ocrCtx.drawImage(video, x, y, w, h, 0, 0, w, h);

    const imgData = ocrCtx.getImageData(0, 0, w, h);
    const data    = imgData.data;
    const bin     = new Uint8Array(w * h);

    for (let i = 0, j = 0; i < data.length; i += 4, j++) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const lum = 0.2126*r + 0.7152*g + 0.0722*b;
      const v   = lum > threshold ? 255 : 0;
      bin[j] = v ? 1 : 0;
      data[i] = data[i+1] = data[i+2] = v;
    }
    ocrCtx.putImageData(imgData, 0, 0);

    if (preview && coordCanvas && coordCtx) {
      coordCanvas.width  = w;
      coordCanvas.height = h;
      coordCtx.imageSmoothingEnabled = false;
      coordCtx.drawImage(ocrCanvas, 0, 0);
    }
    return { bin, w, h };
  }

  function segmentColumns(info) {
    const { bin, w, h } = info;
    const colSums = new Array(w).fill(0);
    for (let x = 0; x < w; x++) {
      let s = 0;
      for (let y = 0; y < h; y++) {
        if (bin[y * w + x]) s++;
      }
      colSums[x] = s;
    }
    const segments = [];
    const MIN_COL = 1;
    let inSeg = false, start = 0;

    for (let x = 0; x < w; x++) {
      if (colSums[x] >= MIN_COL) {
        if (!inSeg) { inSeg = true; start = x; }
      } else if (inSeg) {
        segments.push({ start, end:x-1 });
        inSeg = false;
      }
    }
    if (inSeg) segments.push({ start, end:w-1 });
    return segments;
  }

  function extractDigitPatch(info, seg, marginX=1, marginY=1) {
    const { bin, w, h } = info;
    let sx = Math.max(seg.start - marginX, 0);
    let ex = Math.min(seg.end   + marginX, w-1);
    let sy = marginY;
    let ey = h - 1 - marginY;

    const sw = ex - sx + 1;
    const sh = ey - sy + 1;

    const out = new Uint8Array(DIGIT_W * DIGIT_H);
    for (let oy = 0; oy < DIGIT_H; oy++) {
      const srcY = sy + Math.floor(oy * sh / DIGIT_H);
      for (let ox = 0; ox < DIGIT_W; ox++) {
        const srcX = sx + Math.floor(ox * sw / DIGIT_W);
        const v = bin[srcY * w + srcX] ? 255 : 0;
        out[oy * DIGIT_W + ox] = v;
      }
    }
    return out;
  }

  function diffScore(a, b) {
    let s = 0;
    for (let i = 0; i < a.length; i++) {
      const d = a[i] - b[i];
      s += d * d;
    }
    return s;
  }

  function classifyDigit(patch) {
    let bestDigit = null;
    let bestScore = Infinity;
    for (let d = 0; d <= 9; d++) {
      const tmpl = digitTemplates[d];
      if (!tmpl) continue;
      const s = diffScore(patch, tmpl);
      if (s < bestScore) {
        bestScore = s;
        bestDigit = d;
      }
    }
    return bestDigit;
  }

  function learnFromRect(rect, valueStr) {
    valueStr = (valueStr || '').trim();
    if (!valueStr) { alert('좌표 숫자를 먼저 입력해주세요 (예: 22, 105).'); return; }
    if (!/^\d{1,3}$/.test(valueStr)) { alert('1~3자리 숫자만 입력할 수 있습니다.'); return; }

    const info     = binarizeRegion(rect, true);
    const segments = segmentColumns(info);
    if (segments.length === 0) {
      alert('숫자 세그먼트를 찾지 못했습니다. X/Y/W/H를 다시 확인해주세요.');
      return;
    }

    const chars = valueStr.split('');
    if (segments.length !== chars.length) {
      alert(`이미지에서 찾은 숫자 조각 개수(${segments.length})와 입력한 자릿수(${chars.length})가 다릅니다.`);
      return;
    }

    for (let i = 0; i < chars.length; i++) {
      const d = parseInt(chars[i], 10);
      const patch = extractDigitPatch(info, segments[i]);

      if (!digitTemplates[d]) {
        digitTemplates[d] = patch;
      } else {
        const tmpl = digitTemplates[d];
        for (let k = 0; k < tmpl.length; k++) {
          tmpl[k] = (tmpl[k] + patch[k]) >> 1;
        }
      }
    }
    updateTemplateStatus();
    syncTemplatesToConfig();
    alert(`숫자 ${valueStr} 에 대한 템플릿을 갱신했습니다.`);
  }

  function readNumberByTemplate(rect, preview=false) {
    const info     = binarizeRegion(rect, preview);
    const segments = segmentColumns(info);

    if (segments.length === 0 || segments.length > 3) {
      return { value:null, digits:[], segments };
    }

    const digits = [];
    for (const seg of segments) {
      const patch = extractDigitPatch(info, seg);
      const d     = classifyDigit(patch);
      if (d == null) return { value:null, digits, segments };
      digits.push(d);
    }

    let value = 0;
    for (const d of digits) value = value * 10 + d;
    return { value, digits, segments };
  }

  // ===========================
  // 5. OCR 1회 / 자동 추적 루프
  // ===========================
  async function ocrOnce(doPreview = true) {
    if (!video.srcObject) {
      if (doPreview) alert('먼저 캡쳐를 시작해주세요.');
      return;
    }

    const eastRect = {
      x:Number(eastXInput.value),
      y:Number(eastYInput.value),
      w:Number(eastWInput.value),
      h:Number(eastHInput.value)
    };
    const southRect = {
      x:Number(southXInput.value),
      y:Number(southYInput.value),
      w:Number(southWInput.value),
      h:Number(southHInput.value)
    };

    try {
      const east  = readNumberByTemplate(eastRect,  doPreview);
      const south = readNumberByTemplate(southRect, false);

      const rawEastVal  = east.value;
      const rawSouthVal = south.value;

      pushHistory(eastHistory,  rawEastVal);
      pushHistory(southHistory, rawSouthVal);

      const eastMaj  = majorityValue(eastHistory);
      const southMaj = majorityValue(southHistory);

      const eastCandidate  = eastMaj.count  >= 2 ? eastMaj.value  : rawEastVal;
      const southCandidate = southMaj.count >= 2 ? southMaj.value : rawSouthVal;

      const floorChanged = autoDetectFloorByCoord(rawEastVal, rawSouthVal);

      if (floorChanged) {
        currentEast  = rawEastVal;
        currentSouth = rawSouthVal;
        eastHistory  = [rawEastVal];
        southHistory = [rawSouthVal];
      } else {
        currentEast  = smoothCoord(currentEast,  eastCandidate);
        currentSouth = smoothCoord(currentSouth, southCandidate);
      }

      ocrResultDiv.textContent =
        `동 digits: ${east.digits.join('')} → raw=${rawEastVal}, maj=${eastMaj.value}\n` +
        `남 digits: ${south.digits.join('')} → raw=${rawSouthVal}, maj=${southMaj.value}\n` +
        `적용 좌표: 동 ${currentEast}, 남 ${currentSouth}`;

      if (coordLive) {
        coordLive.textContent = `현재 좌표(스무딩): 동 ${currentEast}, 남 ${currentSouth}`;
      }

      updateNavigation();
    } catch (err) {
      console.error(err);
      ocrResultDiv.textContent = 'OCR 오류: ' + err.message;
    }
  }

  ocrOnceBtn.addEventListener('click', () => ocrOnce(true));

  function startAutoOcr() {
    if (ocrLoopTimer) return;
    if (!video.srcObject) {
      alert('먼저 캡쳐를 시작해주세요.');
      return;
    }

    autoBtn.textContent = '자동 추적 중지';

    ocrLoopTimer = setInterval(async () => {
      if (!video.srcObject) {
        stopAutoOcr();
        clearNavPath();
        currentEast = currentSouth = null;
        return;
      }
      if (ocrBusy) return;
      ocrBusy = true;
      try { await ocrOnce(false); }
      finally { ocrBusy = false; }
    }, OCR_INTERVAL);
  }

  function stopAutoOcr() {
    if (!ocrLoopTimer) return;
    clearInterval(ocrLoopTimer);
    ocrLoopTimer = null;
    autoBtn.textContent = '자동 추적 시작';
  }

  autoBtn.addEventListener('click', () => {
    if (ocrLoopTimer) stopAutoOcr();
    else startAutoOcr();
  });

  // =====================
  // 6. PiP(그림 속 그림) 모드
  // =====================
  function startPipRenderingLoop() {
    if (pipAnimating) return;
    pipAnimating = true;

    const loop = () => {
      if (!pipAnimating) return;
      if (!video || !video.srcObject) {
        pipAnimating = false;
        return;
      }

      const vw = video.videoWidth;
      const vh = video.videoHeight;
      if (vw && vh) {
        if (pipCanvas.width !== vw || pipCanvas.height !== vh) {
          pipCanvas.width  = vw;
          pipCanvas.height = vh;
        }

        pipCtx.drawImage(video, 0, 0, pipCanvas.width, pipCanvas.height);
        pipCtx.drawImage(navCanvas, 0, 0, pipCanvas.width, pipCanvas.height);
      }

      requestAnimationFrame(loop);
    };

    loop();
  }

  function stopPipRenderingLoop() {
    pipAnimating = false;
  }

  async function enterNavPiP() {
    if (!('pictureInPictureEnabled' in document)) {
      alert('이 브라우저는 Picture-in-Picture 기능을 지원하지 않습니다.');
      return;
    }
    if (!video.srcObject) {
      alert('먼저 캡쳐를 시작해주세요.');
      return;
    }

    try {
      startPipRenderingLoop();

      if (!pipVideo) {
        pipVideo = document.createElement('video');
        pipVideo.muted = true;
        pipVideo.playsInline = true;
        pipVideo.srcObject = pipCanvas.captureStream(30);

        pipVideo.addEventListener('leavepictureinpicture', () => {
          exitNavPiP(true);
        });
      }

      await pipVideo.play();
      await pipVideo.requestPictureInPicture();

      pipActive = true;
      pipBtn.textContent = 'PIP 닫기';
      setMainOverlayForPip(true);
    } catch (err) {
      console.error(err);
      alert('PiP 진입 중 오류가 발생했습니다.\n' + err.message);
      stopPipRenderingLoop();
    }
  }

  async function exitNavPiP(fromEvent = false) {
    try {
      if (!fromEvent && document.pictureInPictureElement === pipVideo) {
        await document.exitPictureInPicture();
      }
    } catch (err) {
      console.error(err);
    } finally {
      pipActive = false;
      pipBtn.textContent = 'PIP 모드로 보기';
      stopPipRenderingLoop();
      setMainOverlayForPip(false);
    }
  }

  pipBtn.addEventListener('click', () => {
    if (document.pictureInPictureElement &&
        document.pictureInPictureElement !== pipVideo) {
      document.exitPictureInPicture().catch(()=>{});
      return;
    }

    if (!pipActive) {
      enterNavPiP();
    } else {
      exitNavPiP(false);
    }
  });

  // =====================
  // 7. 서버 설정 <-> UI 동기화
  // =====================
  function ensureServerEntry(id) {
    if (!serverConfig.servers[id]) {
      serverConfig.servers[id] = {
        rect: {
          east: { x:880, y:780, w:20, h:17 },
          south:{ x:930, y:780, w:20, h:17 }
        },
        templates: {}
      };
    }
    return serverConfig.servers[id];
  }

  function syncRectInputsToConfig() {
    const conf = ensureServerEntry(currentServerId);
    conf.rect = {
      east: {
        x: Number(eastXInput.value),
        y: Number(eastYInput.value),
        w: Number(eastWInput.value),
        h: Number(eastHInput.value)
      },
      south: {
        x: Number(southXInput.value),
        y: Number(southYInput.value),
        w: Number(southWInput.value),
        h: Number(southHInput.value)
      }
    };
  }

  function syncTemplatesToConfig() {
    const conf = ensureServerEntry(currentServerId);
    const tmpl = {};
    for (let d = 0; d <= 9; d++) {
      if (digitTemplates[d]) {
        tmpl[d] = Array.from(digitTemplates[d]);
      }
    }
    conf.templates = tmpl;
  }

  function applyServerConfigToUI(serverId) {
    const conf = serverConfig.servers[serverId];
    if (!conf) return;

    const east  = conf.rect?.east;
    const south = conf.rect?.south;

    if (east) {
      eastXInput.value = east.x ?? eastXInput.value;
      eastYInput.value = east.y ?? eastYInput.value;
      eastWInput.value = east.w ?? eastWInput.value;
      eastHInput.value = east.h ?? eastHInput.value;
    }
    if (south) {
      southXInput.value = south.x ?? southXInput.value;
      southYInput.value = south.y ?? southYInput.value;
      southWInput.value = south.w ?? southWInput.value;
      southHInput.value = south.h ?? southHInput.value;
    }

    for (let d = 0; d <= 9; d++) {
      digitTemplates[d] = null;
    }

    if (conf.templates) {
      for (let d = 0; d <= 9; d++) {
        const arr = conf.templates[String(d)];
        if (arr) {
          digitTemplates[d] = new Uint8Array(arr);
        }
      }
    }

    updateTemplateStatus();
  }

  async function loadConfigFromServer() {
    try {
      const res = await fetch(CONFIG_URL, { cache: 'no-store' });
      if (!res.ok) {
        throw new Error('설정 JSON 로드 실패: ' + res.status);
      }
      const data = await res.json();

      serverConfig = {
        version: data.version || 1,
        servers: data.servers || {}
      };

      const serverIds = Object.keys(serverConfig.servers);
      if (!serverIds.length) {
        console.warn('서버 설정이 비어 있습니다. 기본값으로 시작합니다.');
        serverConfig.servers["NOVA&HAPPY"] = {
          rect: {
            east: { x:880, y:780, w:20, h:17 },
            south:{ x:930, y:780, w:20, h:17 }
          },
          templates: {}
        };
      }

      if (!serverConfig.servers[currentServerId]) {
        currentServerId = Object.keys(serverConfig.servers)[0];
      }

      if (serverSelect) {
        serverSelect.value = currentServerId;
      }

      applyServerConfigToUI(currentServerId);
    } catch (e) {
      console.error(e);
      alert('서버 설정 JSON을 불러오지 못했습니다.\n새 설정을 만든 뒤 JSON으로 내보내서 GitHub에 올려 주세요.');
      ensureServerEntry(currentServerId);
      if (serverSelect) serverSelect.value = currentServerId;
      applyServerConfigToUI(currentServerId);
    }
  }

  serverSelect.addEventListener('change', () => {
    currentServerId = serverSelect.value;
    localStorage.setItem('saMajyu:lastServer', currentServerId);
    applyServerConfigToUI(currentServerId);
  });

  [
    eastXInput, eastYInput, eastWInput, eastHInput,
    southXInput, southYInput, southWInput, southHInput
  ].forEach(input => {
    input.addEventListener('change', () => {
      syncRectInputsToConfig();
    });
  });

  learnEastBtn.addEventListener('click', () => {
    if (!video.srcObject) {
      alert('먼저 캡쳐를 시작해주세요.');
      return;
    }
    const eastRect = {
      x:Number(eastXInput.value),
      y:Number(eastYInput.value),
      w:Number(eastWInput.value),
      h:Number(eastHInput.value)
    };
    const valStr = learnEastInput.value;
    learnFromRect(eastRect, valStr);
  });

  clearTemplatesBtn.addEventListener('click', () => {
    for (let d = 0; d <= 9; d++) digitTemplates[d] = null;
    eastHistory  = [];
    southHistory = [];
    currentEast  = null;
    currentSouth = null;
    updateTemplateStatus();
    syncTemplatesToConfig();
    alert('모든 숫자 템플릿을 초기화했습니다.');
  });

  // JSON 내보내기
  function buildExportJson() {
    return JSON.stringify(serverConfig, null, 2);
  }

  exportConfigBtn.addEventListener('click', () => {
    const blob = new Blob([buildExportJson()], { type: 'application/json' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href     = url;
    a.download = 'majyu_ocr_servers.json';
    a.click();
    URL.revokeObjectURL(url);
  });

  // JSON 불러오기
  importConfigInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;

    try {
      const text = await file.text();
      const obj  = JSON.parse(text);

      serverConfig = {
        version: obj.version || 1,
        servers: obj.servers || {}
      };

      const ids = Object.keys(serverConfig.servers);
      if (!ids.length) {
        alert('servers 항목이 비어 있습니다.');
        return;
      }

      if (!serverConfig.servers[currentServerId]) {
        currentServerId = ids[0];
      }

      if (serverSelect) serverSelect.value = currentServerId;
      applyServerConfigToUI(currentServerId);

      alert('설정을 불러왔습니다.\n이 JSON을 GitHub data/majyu_ocr_servers.json 위치에 업로드하면 공유됩니다.');
    } catch (err) {
      console.error(err);
      alert('JSON 파싱에 실패했습니다: ' + err.message);
    } finally {
      importConfigInput.value = '';
    }
  });

  // ================= 8. 관리자 모드 =================
  const adminToggleBtn = document.getElementById('adminToggle');
  let isAdmin = false;

  const ADMIN_HASH = "4f43276989987a73f9beabd8d0fa966b326edd0d9ffc5b987f138d3481a0bec1";
  async function sha256Hex(str){
    if (!window.crypto || !crypto.subtle){
      alert('이 브라우저에서는 관리자 모드를 사용할 수 없습니다 (crypto.subtle 미지원).');
      throw new Error('crypto.subtle not supported');
    }
    const enc = new TextEncoder();
    const data = enc.encode(str);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray  = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2,'0')).join('');
  }

  async function enableAdmin(){
    const pw = prompt('관리자 비밀번호를 입력하세요.');
    if (pw == null) return;
    try{
      const digest = await sha256Hex(pw);
      if (digest === ADMIN_HASH){
        isAdmin = true;
        document.body.classList.add('admin-mode');
        adminToggleBtn.textContent = '관리자 모드 해제';
        alert('관리자 모드가 활성화되었습니다.');
      }else{
        alert('비밀번호가 올바르지 않습니다.');
      }
    }catch(e){
      console.error(e);
      alert('관리자 모드 활성화 중 오류가 발생했습니다.');
    }
  }

  function disableAdmin(){
    isAdmin = false;
    document.body.classList.remove('admin-mode');
    adminToggleBtn.textContent = '관리자 모드';
  }

  adminToggleBtn.addEventListener('click', () => {
    if (isAdmin) disableAdmin();
    else enableAdmin();
  });

  // ================= 9. 초기화 =================
  (async () => {
    const last = localStorage.getItem('saMajyu:lastServer');
    if (last) currentServerId = last;
    if (serverSelect) serverSelect.value = currentServerId;

    await loadConfigFromServer();
    updateTemplateStatus();
  })();

  window.addEventListener('keydown', (e) => {
    if (e.key === 'l' || e.key === 'L') {
      if (currentEast != null && currentSouth != null) {
        console.log(`{ e: ${currentEast}, s: ${currentSouth} },`);
      } else {
        console.log('현재 좌표 없음 (OCR 대기 중)');
      }
    }
  });
</script>
</body>
</html>
